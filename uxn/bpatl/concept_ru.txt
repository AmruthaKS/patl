Каждый блок содержит два раздела: (1) узлы этого блока и (2) ссылки на узлы в других блоках. Также блок содержит статические данные: адрес, по которому он был загружен в память в последний раз для поправки внутренних указателей, флаг dirty, указатель на следующий незанятый участок для размещения нового узла. Блок должен содержать также ссылки на узлы в других блоках, которые содержат обратные связи с узлами в данном блоке. Это нужно для корректировки этих обратных связей из других блоков, когда часть дерева из текущего блока разделяется на два блока или когда сливаются две части дерева из соседних узлов.

---

Есть ассоциативный контейнер, узлы которого хранятся в блоках на внешних носителях. Этот контейнер содержит кэш с копиями блоков, находящимися в памяти. Кэш может содержать ограниченное, задаваемое при его создании, количество блоков. Каждый блок в кэше и на внешнем носителе однозначно идентифицируется по своему bid_type. С bid_type каждого блока в кэше ассоциируется пара (адрес блока в памяти, флаг ридонли). Флаг ридонли == false в случае неконстантного доступа к узлу внутри блока, во всех остальных случаях он == true. Флаг readonly определяет, надо ли записывать содержимое блока в памяти на внешний носитель после окончания работы с ним. Каждый блок, независимо от того где он находится - в памяти или на внешнем носителе, содержит служебную информацию статического размера, располагающуюся в начале блока, а также динамически распределяемые узлы и внешние ссылки (outref). Внутри блока эти сущности адресуются смещением относительно начала блока. Для независимого функционирования к смещению внутри блока нужно добавить bid_type блока и указатель на контейнер.

---

assoc_cont содержит block_cache;
block_cache содержит std::map<node_block::bid_type, std::pair<node_block*, bool> >;
node_block содержит контейнер с произвольным доступом по смещению к node и outref-ссылкам на внешние узлы;
extnode содержит указатель на assoc_cont и node_block::outref

node_generic и algorithm_generic должны быть полностью переписаны;
тип node_type в каждом контейнере должен быть extnode;
тип root_ может быть (node_generic<...>*), потому что корневой блок постоянно в памяти;
в extnode_generic должны быть продублированы все функции node_generic;
extnode_generic не должен внешне отличаться от patl::node_generic;
node_generic должен иметь оператор преобразования в extnode_generic

---

extalgorithm_generic - содержит extnode_generic, используется в vertex_generic, порождает algorithm для локальной работы в vertex.
Напрямую с функциями node_generic работают только algorithm и prefix. Для них нужно написать external_-версии.

---

Функции algorithm могут работать только с узлами, находящимися в памяти. Но в algorithm могут храниться только внешние ссылки на узлы. Это необходимо для представления состояния vertex и всех iterator's. В начале функции, использующей algorithm, должен создаваться объект внутреннего алгоритма (с указателем на закэшированный узел) и с ним должна проводиться работа. В конце функции этот объект деструктуризуется, отпуская участок кэша.

---

const_iterator содержит const_postorder_iterator, который содержит const_vertex, содержащий algorithm. algorithm должен хранить в себе node_block::outref и qid (возможно в составе outref). Этот algorithm, содержащий в себе информацию о внешнем узле, называется extalgorithm. extalgorithm имеет функцию exploit, которая создает объект некоторого внутреннего класса algorithm, который представляет собой тот настоящий algorithm, которым можно непосредственно пользоваться. В конструкторе этого algorithm происходит захват участка кэша с блоком указанного узла, а в деструкторе происходит отпускание захваченного блока кэша.

class vertex {
... exploit_t expl = pal_.exploit();

В exploit(), возможно, придется создавать std::auto_ptr<exploit_t>, чтобы не захватывать и отпускать участок кэша слишком часто. N/RVO, конечно, может сработать, но кто знает заранее?
При выходе объекта exploit_t из зоны видимости, вызывается деструктор и блок кэша отпускается.
В [const_]vertex_generic, [const_](post|pre|level)order_iterator, [const_][reverse_]iterator нужно добавить функции, аналогичные имеющимся, только с первым параметром типа exploit_t.
Хотя, будет лучше иметь в каждом таком классе свою функцию exploit, создающую vertex::exploit_t, (post|pre|level)order_iterator::::exploit_t и т.д. С объектами этих классов и будет происходить работа в каждом отдельном методе итераторов. Классы smth::exploit_t должны иметь интерфейс своих создателей.

class patl_cont
{ ...
	typedef algorithm_generic algorithm;
	typedef vertex_generic vertex;
	typedef postorder_iterator_generic postorder_iterator;
	typedef const_iterator_generic const_iterator;
	...
};	// все эти smth_generic содержат функцию
	// typename smth_generic::exploit_t exploit();
	// typedef smth_generic &exploit_t;
	// т.е., exploit() возвращает *this;

class bpatl_cont
{ ...
	typedef extnode_generic node_type;
	typedef extalgorithm_generic algorithm;
	typedef extvertex_generic vertex;
	typedef extpostorder_iterator_generic postorder_iterator;
	typedef extconst_iterator_generic const_iterator;
	...
	typedef const_node_block_generic const_node_type_ref;
	typedef node_block_generic node_type_ref;
	typedef external_algorithm_generic coralgorithm;
	typedef vertex_generic corvertex;
	typedef postorder_iterator_generic corpostorder_iterator;
	typedef const_iterator_generic corconst_iterator;
	...
};	// все эти extsmth_generic содержат функцию
	// typename extsmth_generic::exploit_t exploit();
	// typedef smth_generic exploit_t;
	// т.е., exploit() создает новый экземпляр smth_generic();

Со взятия exploit_t базового типа начинается каждый метод итератора.
Вызывается extconst_iterator::operator++(). В нем вначале достается extpostorder_iterator::exploit_t с помощью pit_.exploit(). Т.е., создается экземпляр postorder_iterator и с ним работает метод.

---

extalgorithm::exploit() создает экземпляр algorithm, в котором, кроме членов q_ и qid_, должен храниться указатель на создавший его extalgorithm. Тогда в деструкторе algorithm будет обновлен extalgorithm.

Тогда в patl_cont's сохраняем в algorithm указатель на сам контейнер, а в bpatl_cont's в algorithm сохраняем указатель на extalgorithm, который может использоваться для выдачи указателя на контейнер.
Теперь в деструкторе algorithm_generic вызывается cont_prov_->release_provider(CSELF). Эта функция должна быть реализована в extalgorithm и должна обновлять его состояние по состоянию algorithm на момент вызова.
В release_provider() нужно использовать функцию, выдающую outref_t по представлению algorithm в памяти. Этим должен заниматься block_cache.
Как по адресу узла в кэше определить его постоянный внешний адрес (outref)?
Это необходимо сделать при помощи block_cache.

---

Различные промежуточные классы core_algorithm и external_algorithm необходимы потому, что patl::node_generic может обойтись в своей работе без знания о контейнере, тогда как bpatl::node_generic не может осуществлять навигацию по узлам или их изменение без ссылки на контейнер, а точнее на block_cache.
Также для полной идентификации закэшированного узла в block_cache надо передавать указатель на физическое расположение блока в кэше (node_block*). Для этого предусмотрены классы [const_]block_node, выполняющие роль [const_]node_type_ref в bpatl_conts. В этих классах хранится указатель на закэшированный блок и указатель на физическое расположение узла в этом блоке.

В bpatl_cont, как уже выяснилось, все алгоритмосодержащие typedef'ы на самом деле являются extsmth-классами, содержащими функцию exploit(), которая создает экземпляр того класса, который будет делать соответствующую работу.
Что же должен содержать класс extalgorithm_generic?

---

В общем, все уперлось в расширенную иерархию итераторов с const-counterpart'ами. Пока их не будет, все остальное не действует.
Иерархия есть и пока работает нормально. Теперь надо сделать подобную иерархию с префиксами ext*.

---

Полезная мысль, но сейчас не в тему. Сделать функцию: prefix suffix_generic::following(const prefix&) (или другое название), которая будет возвращать суффиксную ссылку. Тогда можно будет вывести suffix_generic::match_iterator наружу, а также сделать класс преобразующий suffix tree в DAG. Для этого нужно продумать взаимные преобразования vertex в prefix. Возможно, у этой функции будет другая сигнатура: vertex suffix_generic::following(const vertex&). Надо подумать, как лучше.

---

Как определить, нужно ли поднимать флаг dirty для запрашиваемого блока кэша, когда создается экземпляр [const_]block_node? Очевидно, это будет зависеть от константности vertex, захватывающего этот блок. Так как у нас расщепленная иерархия const/non-const, то все const-итераторы будут содержать в конечном счете const_vertex. Соответственно будет для non-const. Итак, определять флаг dirty при захвате блока кэша должен [const_]vertex. Однако, при движении по дереву algorithm будет пробегать разные блоки и каждый адресуемый таким образом блок надо захватывать, а при прекращении адресации - отпускать. Причем, благодаря косвенной адресации узлов в PATRICIA, в случаях ссылки узла из одного блока на узел в другом блоке необходимо захватить оба этих блока до перемещения указателя целиком в один блок. Следовательно, algorithm должен каким-то образом зависеть в способе dirty/non-dirty захвата от vertex, частью которого он является.

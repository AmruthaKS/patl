Каждый блок содержит два раздела: (1) узлы этого блока и (2) ссылки на узлы в других блоках. Также блок содержит статические данные: адрес, по которому он был загружен в память в последний раз для поправки внутренних указателей, флаг dirty, указатель на следующий незанятый участок для размещения нового узла. Блок должен содержать также ссылки на узлы в других блоках, которые содержат обратные связи с узлами в данном блоке. Это нужно для корректировки этих обратных связей из других блоков, когда часть дерева из текущего блока разделяется на два блока или когда сливаются две части дерева из соседних узлов.

---

Есть ассоциативный контейнер, узлы которого хранятся в блоках на внешних носителях. Этот контейнер содержит кэш с копиями блоков, находящимися в памяти. Кэш может содержать ограниченное, задаваемое при его создании, количество блоков. Каждый блок в кэше и на внешнем носителе однозначно идентифицируется по своему bid_type. С bid_type каждого блока в кэше ассоциируется пара (адрес блока в памяти, флаг ридонли). Флаг ридонли == false в случае неконстантного доступа к узлу внутри блока, во всех остальных случаях он == true. Флаг readonly определяет, надо ли записывать содержимое блока в памяти на внешний носитель после окончания работы с ним. Каждый блок, независимо от того где он находится - в памяти или на внешнем носителе, содержит служебную информацию статического размера, располагающуюся в начале блока, а также динамически распределяемые узлы и внешние ссылки (outref). Внутри блока эти сущности адресуются смещением относительно начала блока. Для независимого функционирования к смещению внутри блока нужно добавить bid_type блока и указатель на контейнер.

---

assoc_cont содержит block_cache;
block_cache содержит std::map<node_block::bid_type, std::pair<node_block*, bool> >;
node_block содержит контейнер с произвольным доступом по смещению к node и outref-ссылкам на внешние узлы;
extnode содержит указатель на assoc_cont и node_block::outref

node_generic и algorithm_generic должны быть полностью переписаны;
тип node_type в каждом контейнере должен быть extnode;
тип root_ может быть (node_generic<...>*), потому что корневой блок постоянно в памяти;
в extnode_generic должны быть продублированы все функции node_generic;
extnode_generic не должен внешне отличаться от patl::node_generic;
node_generic должен иметь оператор преобразования в extnode_generic

---

extalgorithm_generic - содержит extnode_generic, используется в vertex_generic, порождает algorithm для локальной работы в vertex. Если нет algorithm_cache, находящийся в assoc_cont, и содержащий рабочие инстансы algorithm
Напрямую с функциями node_generic работают только algorithm и prefix. Для них нужно написать external_-версии

---

Функции algorithm могут работать только с узлами, находящимися в памяти. Но в algorithm могут храниться только внешние ссылки

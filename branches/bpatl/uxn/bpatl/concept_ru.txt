Каждый блок содержит два раздела: (1) узлы этого блока и (2) ссылки на узлы в других блоках. Также блок содержит статические данные: адрес, по которому он был загружен в память в последний раз для поправки внутренних указателей, флаг dirty, указатель на следующий незанятый участок для размещения нового узла. Блок должен содержать также ссылки на узлы в других блоках, которые содержат обратные связи с узлами в данном блоке. Это нужно для корректировки этих обратных связей из других блоков, когда часть дерева из текущего блока разделяется на два блока или когда сливаются две части дерева из соседних узлов.

---

Есть ассоциативный контейнер, узлы которого хранятся в блоках на внешних носителях. Этот контейнер содержит кэш с копиями блоков, находящимися в памяти. Кэш может содержать ограниченное, задаваемое при его создании, количество блоков. Каждый блок в кэше и на внешнем носителе однозначно идентифицируется по своему bid_type. С bid_type каждого блока в кэше ассоциируется пара (адрес блока в памяти, флаг ридонли). Флаг ридонли == false в случае неконстантного доступа к узлу внутри блока, во всех остальных случаях он == true. Флаг readonly определяет, надо ли записывать содержимое блока в памяти на внешний носитель после окончания работы с ним. Каждый блок, независимо от того где он находится - в памяти или на внешнем носителе, содержит служебную информацию статического размера, располагающуюся в начале блока, а также динамически распределяемые узлы и внешние ссылки (outref). Внутри блока эти сущности адресуются смещением относительно начала блока. Для независимого функционирования к смещению внутри блока нужно добавить bid_type блока и указатель на контейнер.

---

assoc_cont содержит block_cache;
block_cache содержит std::map<node_block::bid_type, std::pair<node_block*, bool> >;
node_block содержит контейнер с произвольным доступом по смещению к node и outref-ссылкам на внешние узлы;
extnode содержит указатель на assoc_cont и node_block::outref

node_generic и algorithm_generic должны быть полностью переписаны;
тип node_type в каждом контейнере должен быть extnode;
тип root_ может быть (node_generic<...>*), потому что корневой блок постоянно в памяти;
в extnode_generic должны быть продублированы все функции node_generic;
extnode_generic не должен внешне отличаться от patl::node_generic;
node_generic должен иметь оператор преобразования в extnode_generic

---

extalgorithm_generic - содержит extnode_generic, используется в vertex_generic, порождает algorithm для локальной работы в vertex. Если нет algorithm_cache, находящийся в assoc_cont, и содержащий рабочие инстансы algorithm
Напрямую с функциями node_generic работают только algorithm и prefix. Для них нужно написать external_-версии

---

Функции algorithm могут работать только с узлами, находящимися в памяти. Но в algorithm могут храниться только внешние ссылки на узлы. Это необходимо для представления состояния vertex и всех iterator's. В начале функции, использующей algorithm, должен создаваться объект внутреннего алгоритма (с указателем на закэшированный узел) и с ним должна проводиться работа. В конце функции этот объект деструктуризуется, освобождая участок кэша.

---

const_iterator содержит postorder_iterator, который содержит vertex, содержащий algorithm. algorithm должен хранить в себе node_block::outref и qid (возможно в составе outref). Этот algorithm, содержащий в себе информацию о внешнем узле, называется extalgorithm. extalgorithm имеет функцию exploit, которая создает объект некоторого внутреннего класса algorithm, который представляет собой тот настоящий algorithm, которым можно непосредственно пользоваться. В конструкторе этого algorithm происходит захват участка кэша с блоком указанного узла, а в деструкторе происходит отпускание захваченного блока кэша.

class vertex {
... exploit_t expl = pal_.exploit();

При выходе объекта exploit_t из зоны видимости, вызывается деструктор и блок кэша отпускается.
В vertex_generic, (post|pre|level)order_iterator, [const_][reverse_]iterator нужно добавить функции, аналогичные имеющимся, только с первым параметром типа exploit_t.
Хотя, будет лучше иметь в каждом таком классе свою функцию exploit, создающую exploit_vertex, exploit_(post|pre|level)order_iterator и т.д. С объектами этих классов и будет происходить работа в каждом отдельном методе итераторов. Классы exploit_smth должны иметь интерфейс своих создателей.

class patl_cont
{ ...
	typedef algorithm_generic algorithm;
	typedef vertex_generic vertex;
	typedef postorder_iterator_generic postorder_iterator;
	typedef const_iterator_generic const_iterator;
	...
};	// все эти smth_generic содержат функцию
	// typename smth_generic::exploit_t exploit();
	// typedef smth_generic &exploit_t;
	// т.е., exploit() возвращает *this;

class bpatl_cont
{ ...
	typedef extalgorithm_generic algorithm;
	typedef extvertex_generic vertex;
	typedef extpostorder_iterator_generic postorder_iterator;
	typedef extconst_iterator_generic const_iterator;
	...
};	// все эти extsmth_genric содержат функцию
	// typename extsmth_generic::exploit_t exploit();
	// typedef smth_generic exploit_t;
	// т.е., exploit() создает новый экземпляр smth_generic();

Со взятия exploit_t базового типа начинается каждый метод итератора.
Вызывается extconst_iterator::operator++(). В нем вначале достается extpostorder_iterator::exploit_t с помощью pit_.exploit(). Т.е., создается экземпляр postorder_iterator и с ним работает метод.

---

extalgorithm::exploit() создает экземпляр algorithm, в котором, кроме членов q_ и qid_, должен храниться указатель на создавший его extalgorithm. Тогда в деструкторе algorithm будет обновлен extalgorithm.

Тогда в patl_cont's сохраняем в algorithm указатель на сам контейнер, а в bpatl_cont's в algorithm сохраняем указатель на extalgorithm, который может использоваться для выдачи указателя на контейнер.
Теперь в деструкторе algorithm_generic вызывается cont_prov_->release_provider(). Эта функция должна быть реализована в extalgorithm и должна обновлять его состояние по состоянию algorithm на момент вызова.
В release_provider() нужно использовать функцию, выдающую outref_t по представлению algorithm в памяти. Этим должен заниматься block_cache.
Как по адресу узла в кэше определить его постоянный внешний адрес (outref)?
